name: Upload Photo from Website

# Concurrency lock - ensures only one upload workflow runs at a time
concurrency:
  group: photo-uploads
  cancel-in-progress: false  # Queue uploads instead of canceling them

on:
  workflow_dispatch:
    inputs:
      filename:
        description: 'The name of the file to upload'
        required: true
      blob_sha:
        description: "The SHA of the file's blob content"
        required: true
      person_id:
        description: 'ID of the person this photo belongs to'
        required: false
      person_name:
        description: 'Name of the person this photo belongs to'
        required: false

jobs:
  create-commit:
    runs-on: ubuntu-latest

    steps:
      - name: '‚úÖ Token authenticated! Processing upload'
        run: |
          echo "‚úÖ Authentication verified via token permissions"
          echo "Processing photo upload..."

      - name: '‚úÖ Password OK! Create commit via API'
        env:
          GH_TOKEN: ${{ secrets.GRISSI_TOKEN_PAT }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          BRANCH: 'master'
          FILENAME: ${{ github.event.inputs.filename }}
          BLOB_SHA: ${{ github.event.inputs.blob_sha }}
          PERSON_NAME: ${{ github.event.inputs.person_name }}
        run: |
          set -e # Exit immediately if a command fails

          # --- DEBUGGING STEP ---
          echo "Received Blob SHA: --->${BLOB_SHA}<---"
          if [[ -z "$BLOB_SHA" ]]; then
            echo "::error::Blob SHA is empty! The workflow cannot continue."
            exit 1
          fi
          echo "‚úÖ Blob SHA is valid"
          # --- END OF DEBUGGING STEP ---

          # Handle existing photos by renaming old one with timestamp
          base_name="${FILENAME%.*}"
          extension="${FILENAME##*.}"
          final_filename="$FILENAME"
          file_path="images/arvore/$final_filename"
          
          echo "1. Checking for existing photos with same person name..."
          # Check for ANY existing photo with same base name (any extension)
          EXISTING_FILE_SHA=""
          EXISTING_FILE_NAME=""
          
          # Get current photo manifest to find existing photos
          MANIFEST_RESPONSE=$(curl -s \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$OWNER/$REPO/contents/images/arvore/photo-manifest.json")
          
          MANIFEST_CONTENT=$(echo "$MANIFEST_RESPONSE" | jq -r '.content' | base64 -d)
          
          # Look for existing photo with same base name but any extension
          EXISTING_PHOTO=$(echo "$MANIFEST_CONTENT" | jq -r --arg basename "$base_name" '
            .[] | select(test("^" + $basename + "\\.(jpg|jpeg|png|gif|webp)$"; "i"))
          ' | head -1)
          
          if [ -n "$EXISTING_PHOTO" ] && [ "$EXISTING_PHOTO" != "null" ]; then
            echo "   - Found existing photo: $EXISTING_PHOTO"
            
            # Get the SHA of the existing photo
            existing_path="images/arvore/$EXISTING_PHOTO"
            if EXISTING_RESPONSE=$(gh api "repos/$OWNER/$REPO/contents/$existing_path" 2>/dev/null); then
              EXISTING_FILE_SHA=$(echo "$EXISTING_RESPONSE" | jq -r '.sha')
              EXISTING_FILE_NAME="$EXISTING_PHOTO"
              
              # Create timestamp suffix for old photo (keep its original extension)
              timestamp=$(date +"%Y%m%d_%H%M%S")
              existing_extension="${EXISTING_PHOTO##*.}"
              old_filename="${base_name}_${timestamp}.${existing_extension}"
              old_file_path="images/arvore/$old_filename"
              echo "   - Will rename $EXISTING_PHOTO to: $old_filename"
            else
              echo "   - Could not get SHA for existing photo: $EXISTING_PHOTO"
            fi
          else
            echo "   - No existing photo found for person: $base_name"
          fi

          # Create commit message with person info if provided
          if [ -n "$PERSON_NAME" ]; then
            if [ -n "$EXISTING_FILE_SHA" ]; then
              commit_message="üîÑ Update photo for $PERSON_NAME: $final_filename (archived previous version)"
            else
              commit_message="üñºÔ∏è Add photo for $PERSON_NAME: $final_filename"
            fi
          else
            if [ -n "$EXISTING_FILE_SHA" ]; then
              commit_message="üîÑ Update image: $final_filename (archived previous version)"
            else
              commit_message="üñºÔ∏è Add new image: $final_filename"
            fi
          fi

          echo "2. Getting latest commit SHA..."
          LATEST_COMMIT_SHA=$(gh api "repos/$OWNER/$REPO/git/ref/heads/$BRANCH" --jq '.object.sha')
          echo "   - Latest commit: $LATEST_COMMIT_SHA"

          echo "3. Getting base tree SHA..."
          BASE_TREE_SHA=$(gh api "repos/$OWNER/$REPO/git/commits/$LATEST_COMMIT_SHA" --jq '.tree.sha')
          echo "   - Base tree: $BASE_TREE_SHA"

          echo "4. Preparing manifest update..."
          # Get current photo-manifest.json
          MANIFEST_PATH="images/arvore/photo-manifest.json"
          MANIFEST_RESPONSE=$(curl -s \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$OWNER/$REPO/contents/$MANIFEST_PATH")
          
          MANIFEST_CONTENT=$(echo "$MANIFEST_RESPONSE" | jq -r '.content' | base64 -d)
          MANIFEST_SHA=$(echo "$MANIFEST_RESPONSE" | jq -r '.sha')
          
          # Update manifest: remove old entry (if exists) and add new entry
          if echo "$MANIFEST_CONTENT" | grep -q "\"$final_filename\""; then
            echo "   - Photo already in manifest: $final_filename"
            MANIFEST_BLOB_SHA=""
          else
            echo "   - Photo will be added to manifest: $final_filename"
            
            # Start with current manifest
            UPDATED_MANIFEST="$MANIFEST_CONTENT"
            
            # If we found an existing photo to archive, remove its manifest entry
            if [ -n "$EXISTING_FILE_NAME" ] && [ "$EXISTING_FILE_NAME" != "null" ]; then
              echo "   - Removing old manifest entry: $EXISTING_FILE_NAME"
              UPDATED_MANIFEST=$(echo "$UPDATED_MANIFEST" | jq --arg old_photo "$EXISTING_FILE_NAME" 'map(select(. != $old_photo))')
            fi
            
            # Add the new photo to manifest
            NEW_MANIFEST=$(echo "$UPDATED_MANIFEST" | jq ". + [\"$final_filename\"] | sort")
            NEW_MANIFEST_B64=$(echo -n "$NEW_MANIFEST" | base64 -w 0)
            
            # Create blob for updated manifest
            MANIFEST_BLOB_SHA=$(curl -s -X POST \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$OWNER/$REPO/git/blobs" \
              -d "{\"content\": \"$NEW_MANIFEST_B64\", \"encoding\": \"base64\"}" | jq -r '.sha')
            
            echo "   - Manifest blob created: $MANIFEST_BLOB_SHA"
          fi

          echo "5. Creating new tree..."
          # Build tree array based on what needs to be included
          TREE_ITEMS=()
          
          # Always include the new photo
          TREE_ITEMS+=("{\"path\": \"$file_path\", \"mode\": \"100644\", \"type\": \"blob\", \"sha\": \"$BLOB_SHA\"}")
          
          # If there was an existing photo, rename it (archive old version)
          if [ -n "$EXISTING_FILE_SHA" ]; then
            TREE_ITEMS+=("{\"path\": \"$old_file_path\", \"mode\": \"100644\", \"type\": \"blob\", \"sha\": \"$EXISTING_FILE_SHA\"}")
            echo "   - Including old photo rename: $old_filename"
          fi
          
          # Include manifest update if needed
          if [ -n "$MANIFEST_BLOB_SHA" ]; then
            TREE_ITEMS+=("{\"path\": \"$MANIFEST_PATH\", \"mode\": \"100644\", \"type\": \"blob\", \"sha\": \"$MANIFEST_BLOB_SHA\"}")
            echo "   - Including manifest update"
          fi
          
          # Join array elements with commas
          TREE_JSON="[$(IFS=','; echo "${TREE_ITEMS[*]}")]"
          echo "   - Tree will include ${#TREE_ITEMS[@]} file(s)"
          
          NEW_TREE_SHA=$(curl -s -X POST \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$OWNER/$REPO/git/trees" \
            -d "{\"base_tree\": \"$BASE_TREE_SHA\", \"tree\": $TREE_JSON}" | jq -r '.sha')
          echo "   - New tree: $NEW_TREE_SHA"

          echo "6. Creating new commit..."
          # Create detailed commit message
          commit_details=""
          if [ -n "$EXISTING_FILE_SHA" ]; then
            commit_details="${commit_details}üì¶ Archived previous photo as: $old_filename"$'\n'
          fi
          if [ -n "$MANIFEST_BLOB_SHA" ]; then
            commit_details="${commit_details}üì∏ Updated photo manifest"
          fi
          
          if [ -n "$commit_details" ]; then
            commit_message="$commit_message"$'\n\n'"$commit_details"
          fi
          
          # Escape commit message for JSON
          commit_message_escaped=$(printf '%s' "$commit_message" | jq -R -s .)
          
          COMMIT_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$OWNER/$REPO/git/commits" \
            -d "{
              \"message\": $commit_message_escaped,
              \"parents\": [\"$LATEST_COMMIT_SHA\"],
              \"tree\": \"$NEW_TREE_SHA\"
            }")
          
          NEW_COMMIT_SHA=$(echo "$COMMIT_RESPONSE" | jq -r '.sha')
          echo "   - New commit: $NEW_COMMIT_SHA"
          
          # Check if commit creation failed
          if [ "$NEW_COMMIT_SHA" = "null" ] || [ -z "$NEW_COMMIT_SHA" ]; then
            echo "‚ùå Commit creation failed. Response:"
            echo "$COMMIT_RESPONSE" | jq '.'
            exit 1
          fi

          echo "7. Updating branch reference..."
          gh api "repos/$OWNER/$REPO/git/refs/heads/$BRANCH" -X PATCH \
            -f sha="$NEW_COMMIT_SHA"
            
          echo "‚úÖ Successfully committed $final_filename"